This branch is a total rewrite of the user-facing parts of Paintjob Packer, in order to make it less fiddly and hopefully laying the foundation for a public release.

Goal: simplify user experience

Remove pack library system
- too much work to set up/use each pack
- very little benefit in the end, pack addons aren't created often enough, and full packs are never re-generated
- needlessly complex (and unneeded) for a public release

Overhaul mod creation experience
- simple inputs that can be easily translated into a GUI
- additional modes (one paintjob/full pack, one cabin/a b c paintjobs)



Widget hierarchy:
root
	container                       frame
		setup_screen                  frame
			tab_selector 					      notebook
				tab_game 				          frame
					tab_game_title 			    label
					tab_game_image_left		  label
					tab_game_image_right	  label
					tab_game_option_left	  checkbutton
					tab_game_option_right	  checkbutton
					tab_game_desc_left		  label
					tab_game_desc_right		  label
					tab_game_button_left	  button
					tab_game_button_right	  button
				tab_paintjob 				      frame
				tab_cabin 					      frame
		main_screen 						      frame
			panel_mod                   labelframe
				panel_mod_name_label		  label
				panel_mod_name_input		  input
				panel_mod_name_help			  button
			panel_ingame                labelframe
				panel_ingame_default		  checkbutton
			panel_internal              labelframe
			panel_vehicles
				panel_vehicles_selector		notebook
					tab_trucks				      frame
						truck_daf_xf		      checkbutton
					tab_trailers			      frame
					tab_mods				        frame
						mod_ford_fmax		      checkbutton
						mod_link_ford_fmax	  label
			panel_buttons
				panel_buttons_setup			  button
				panel_buttons_feedback		label
				panel_buttons_generate		button



Store things in variables
widgets aren't garbage collected, if not stored in a variable they can't be affected
e.g. don't just ttk.Button, but my_butt = ttk.Button

Geometry managers
geometry: grid (just like a typographic grid!)
pack for simple plopping, place for specific location
only stick to one within each parent widget

Event handling
event loop handles only one event at a time
they're queued while handlers are running
>> make sure handlers are fast, and a second action doesn't get queued when it doesn't need to be

Making widgets execute functions
widgets respond to events with "command" property
widgets without a command, use a "bind" property (e.g. enter for mouseover)

The app class
implementing the app as a class is commonplace for bigger projects, probably best practice (e.g. name: HelloApp)
constructors are in the __init__() ---> __init__(self, master) so it can be bound to root, or whatever else
handlers are functions within the class

Using images (in labels)
img = tk.PhotoImage(file = "C:\\Users\\Carsmaniac\\Desktop\\Ex_Files_Python_GUI_Dev_Tkinter\\Exercise Files\\Ch03\\python_logo.gif") # GIF only!
label.config(image = img)
label.config(compound = "text") # text = the text, image = the image, center = text centred on image, left = image to the left of text (right/top/bottom)
note: PhotoImage can be garbage collected, save it in a variable that sticks around (not a local in a func)
smol_img = img.subsample(5,5) # makes a new image out of every 5th pixel of img, specify x then y

Disabling buttons
button.state(["disabled"]) # "!disabled" to enable
button.instate(["disabled"]) # to check if it's disabled or not

Variables that need to be changed
StringVar, IntVar, BooleanVar, DoubleVar (float)
StringVar.get(), StringVar.set("string here")
checkbutton = tk.Checkbutton(root)
checkbutton.config(variable = my_bool_var)
checkbutton.config(variable = my_string_var, onvalue = "Selected", offvalue = "Not selected") # without on/offvalue, defaults to "1" and "0"
radiobutton.config(value = "This button is selected") # rather than on/off, like a checkbox
label.config(textvariable = my_string_var) # to use a StringVar as the label, use "textvariable" rather than "text"

Text inputs
entry = ttk.Entry(root, width = x) # is num of characters (does not limit)
entry.get() # the contents of it. cannot set()
entry.delete(5, 6) # deletes characters from the fifth (0 index) to sixth position, can do (5, "end") to leave first 5 only, for example
entry.config(show = "*") # shows all characters as that string, e.g. for password field
entry.state(["readonly"]) # user can select but not change, !readonly to undo, can also disabled/!disabled (set separately)

Drop-downs and spinboxes
dropdown = ttk.Combobox(root, textvariable = my_str_var) # textvariable to make it gettable and settable
dropdown.config(values = ["list", "of", "strings"])
dropdown.config(state = "readonly") # can only select an option, not type in a custom one
spinbox = tk.Spinbox(root, textvariable = my_str_var, from_ = 1900, to = 2020) # not a part of ttk, use from_ not from

Progress bar and sliding inputs
progressbar = ttk.Progressbar(root, orient = "horizontal", length = 200) # length in pixels
progressbar.config(mode = "indeterminate"), progressbar.start(), progressbar.stop() # for processes where you don't know how many need to happen/how far long it is
progressbar.config(mode = "determinate", maximum = 14.0, value = 3.0) # both numbers are floats
progressbar.step() # increments value by 1.0, or supply a number to change how much
progressbar.config(variable = my_double_var) # to use a variable, probably a good idea
sliding = ttk.Scale(root, orient, width, variable = my_double_var, from_ = 0.0, to = 10.0)
sliding.get(), sliding.set()

Frames
Organise widgets, each can use different geometry managers (put the widget's parent as the frame, rather than root)
frame = ttk.Frame(root, relief = "solid", padding = [5, 5]) # relief = flat, raised, sunked, solid, ridge, groove; padding is x and y in pixels
labelframe = ttk.LabelFrame(root, padding, text = "This section's name") # always has a solid relief, note capital F in Label Frame

Additional windows
window = tk.Toplevel(root)
window.title("Window title") # also for root
window.state("a state") # zoomed = max size, iconic = minimised, normal = not minimised (minimised > zoomed if it was before, then zoomed > normal), withdrawn = hidden completely
window.iconify(), window.deiconify() # minimise or un-minimise
window.geometry("1x2+3+4") # width "x" height "+" x pos "+" y pos
window.resizable(False, False) # x, y resizability
window.maxsize(1280, 720), window.minsize(800, 600)
window.destry() # close/delete a widget, and all children (destroy root to get rid of everything)

Resizable sections in a window
panedwindow = ttk.Panedwindow(root, orient = "horizontal") # use like a frame, not like a window
frame = ttk.Frame(root) # parent is root, not panedwindow
panedwindow.add(frame, weight = 2) # add it to the right, weight is optional - no weight = will not change as window resizes, weight = change in ratio (e.g. wght 1 | wght 2, will stay in ratio 1:2)
panedwindow.insert(index, frame, [weight]) # 0 for the left (or top if vert orient), 1 for after the first, etc
panedwindow.forget(index) # does not destroy frame, just removes from panedwindow
Flat frame w/ weight | sunken frame w/o weight, good for a little sidebar

Tabbed windows
notebook = ttk.Notebook(root)
frame1 = ttk.Frame(notebook) # parent is notebook
notebook.add(frame1, text = "Tab label")
notebook.insert(index, frame1, text = "Label") # index 0 = left, 1 for after first, etc
notebook.forget(index)
notebook.index(notebook.select()) # to get the index of the selected tab, just select() gives its annoying internal name (t?)
notebook.select(index) # programatically selects a tab
notebook.tab(index, state = "disabled") # disabled, hidden, normal. Also change other properties like text this way, tab(index, "state") to see current state

Text boxes
text = tk.Text(root, width = 20, height = 10) # width and height in characters, note not ttk
text.config(wrap = "word") # none, char, word
text.get("start index", "end index") # start and end can be "int.int" for line, char (lines index from 1, chars from 0, so 1.0 for the beginning), or "end" for the end. Can also do "1.end"
Can also append " + 3 lines", " + 4 chars" to do those things, " linestart" /lineend/wordstart/wordend to jump there, e.g. ("1.0", "1.20 wordend") will get first 20 chars of first line, plus the rest of the last word if it's cut off
Note for get: wrapped lines don't count as new lines, a new line only starts when Enter is pressed
text.insert("1.0 + 3 lines", "Some text") # inserts text at index, in this case after three lines, can include \n for multi-line
text.delete("start index", "end index")
text.config(state = "disabled") # or normal, disallows changes (including by insert()/delete())

Text box tags
text.tag_add("tag name", "start index", "end index")
text.tag_configure("tag name", properties) # e.g. change the background/colour of one part of it
text.tag_remove("tag name", "start index", "end index") # removes that range from the tag
text.tag_names() # returns a list of tags, including "sel" which is the text selected by a user
Tags can also be start/end indexes, e.g. "tag name.first", "tag name.last"
text.tag_delete("tag name") # deletes tag completely
my_image = tk.PhotoImage()
text.image_create("index", my_image) # adds image to the text box at the index

Grid manager
Plan out ahead of time, including rowspans and columnspans
root.rowconfigure(0, weight = 2) # first column, with a weight of 2 (weight of 0 = no expand)
Also columnconfigure
thing.grid(row = 0, column = 0, rowspan = 2, columnspan = 3, sticky = "ns", padx = 10, pady, ipadx, ipady) # sticky/stick uses compass, padx/pady adds padding around, ipadx/ipady adds padding inside

String formatting
"I am %s years old, my birthday is on the %s" % ("20", "6th of July")     # older, type has to be correct: %s only ever takes a string, cannot take an int
"I am {} years old, my birthday is on the {}".format(20, "6th of July")   # new in Python 3, type can be whatever, e.g. an int here

Hyperlinks
import webbrowser
label = ttk.Label(root, text = "Click me!", color = "blue", cursor = "hand2") # hand2 for windows, pointinghand for macOS, hand2 for Linux??; if sys.platform.startswith('darwin') > macOS, 'win32' > windows, 'linux' > linux
label.bind("<1>", lambda e: webbrowser.open_new("http://google.com"))
